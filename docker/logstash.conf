input {
  beats { port => 5044 }  
  # Lecture de fichiers CSV pour tests
  file {
    path => "/usr/share/logstash/logs/*.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
  }
}

filter {
  # Parse des logs au format UNSW-NB15
  csv {
    separator => ","
    columns => [
      "id", "dur", "proto", "service", "state", "spkts", "dpkts", "sbytes", "dbytes",
      "rate", "sttl", "dttl", "sload", "dload", "sloss", "dloss", "sinpkt", "dinpkt",
      "sjit", "djit", "swin", "stcpb", "dtcpb", "dwin", "tcprtt", "synack", "ackdat",
      "smean", "dmean", "trans_depth", "response_body_len", "ct_srv_src", "ct_state_ttl",
      "ct_dst_ltm", "ct_src_dport_ltm", "ct_dst_sport_ltm", "ct_dst_src_ltm", "is_ftp_login",
      "ct_ftp_cmd", "ct_flw_http_mthd", "ct_src_ltm", "ct_srv_dst", "is_sm_ips_ports"
    ]
    skip_header => true
  }

  # Conversion des types (complète)
  mutate {
    convert => {
      "id" => "integer"
      "dur" => "float"
      "spkts" => "integer"
      "dpkts" => "integer"
      "sbytes" => "integer"
      "dbytes" => "integer"
      "rate" => "float"
      "sttl" => "integer"
      "dttl" => "integer"
      "sload" => "float"
      "dload" => "float"
      "sloss" => "integer"
      "dloss" => "integer"
      "sinpkt" => "float"
      "dinpkt" => "float"
      "sjit" => "float"
      "djit" => "float"
      "swin" => "integer"
      "stcpb" => "integer"
      "dtcpb" => "integer"
      "dwin" => "integer"
      "tcprtt" => "float"
      "synack" => "float"
      "ackdat" => "float"
      "smean" => "float"
      "dmean" => "float"
      "trans_depth" => "integer"
      "response_body_len" => "integer"
      "ct_srv_src" => "integer"
      "ct_state_ttl" => "integer"
      "ct_dst_ltm" => "integer"
      "ct_src_dport_ltm" => "integer"
      "ct_dst_sport_ltm" => "integer"
      "ct_dst_src_ltm" => "integer"
      "is_ftp_login" => "integer"
      "ct_ftp_cmd" => "integer"
      "ct_flw_http_mthd" => "integer"
      "ct_src_ltm" => "integer"
      "ct_srv_dst" => "integer"
      "is_sm_ips_ports" => "integer"
    }
  }
  # Appel du service ML avec gestion d'erreurs
  http {
    url => "http://pfa-dev:8000/detect/single"
    http_method => "post"
    body_format => "json"
    headers => {
      "Content-Type" => "application/json"
    }
    body => {
      "id" => "%{id}"
      "dur" => "%{dur}"
      "proto" => "%{proto}"
      "service" => "%{service}"
      "state" => "%{state}"
      "spkts" => "%{spkts}"
      "dpkts" => "%{dpkts}"
      "sbytes" => "%{sbytes}"
      "dbytes" => "%{dbytes}"
      "rate" => "%{rate}"
      "sttl" => "%{sttl}"
      "dttl" => "%{dttl}"
      "sload" => "%{sload}"
      "dload" => "%{dload}"
      "sloss" => "%{sloss}"
      "dloss" => "%{dloss}"
      "sinpkt" => "%{sinpkt}"
      "dinpkt" => "%{dinpkt}"
      "sjit" => "%{sjit}"
      "djit" => "%{djit}"
      "swin" => "%{swin}"
      "stcpb" => "%{stcpb}"
      "dtcpb" => "%{dtcpb}"
      "dwin" => "%{dwin}"
      "tcprtt" => "%{tcprtt}"
      "synack" => "%{synack}"
      "ackdat" => "%{ackdat}"
      "smean" => "%{smean}"
      "dmean" => "%{dmean}"
      "trans_depth" => "%{trans_depth}"
      "response_body_len" => "%{response_body_len}"
      "ct_srv_src" => "%{ct_srv_src}"
      "ct_state_ttl" => "%{ct_state_ttl}"
      "ct_dst_ltm" => "%{ct_dst_ltm}"
      "ct_src_dport_ltm" => "%{ct_src_dport_ltm}"
      "ct_dst_sport_ltm" => "%{ct_dst_sport_ltm}"
      "ct_dst_src_ltm" => "%{ct_dst_src_ltm}"
      "is_ftp_login" => "%{is_ftp_login}"
      "ct_ftp_cmd" => "%{ct_ftp_cmd}"
      "ct_flw_http_mthd" => "%{ct_flw_http_mthd}"
      "ct_src_ltm" => "%{ct_src_ltm}"
      "ct_srv_dst" => "%{ct_srv_dst}"
      "is_sm_ips_ports" => "%{is_sm_ips_ports}"
    }
    target_body => "ml_detection"
    connect_timeout => 10
    request_timeout => 30
  }
  # Enrichissement avec les résultats ML
  if [ml_detection] {
    ruby {
      code => '
        detection = event.get("ml_detection")
        if detection.is_a?(Hash)
          event.set("is_attack", detection["is_attack"])
          event.set("attack_probability", detection["attack_probability"])
          event.set("confidence", detection["confidence"])
          event.set("alert_generated", detection["alert_generated"])
          event.set("ml_predictions", detection["ml_predictions"])
        end
      '
    }
  } else {
    # Si pas de réponse ML, marquer comme erreur
    mutate {
      add_field => { "ml_error" => "No response from ML service" }
      add_field => { "is_attack" => false }
      add_field => { "confidence" => 0.0 }
    }
  }

  # Ajout de métadonnées
  mutate {
    add_field => { "[@metadata][index_prefix]" => "network-intrusion" }
    add_field => { "log_type" => "network_flow" }
    add_field => { "processed_at" => "%{@timestamp}" }
  }
}

output {
  # Stockage principal dans Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "network-intrusion-%{+YYYY.MM.dd}"
    document_type => "_doc"
    template_name => "network-intrusion"
    template_pattern => "network-intrusion-*"
    template => {
      "index_patterns" => ["network-intrusion-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "id" => { "type" => "long" }
          "is_attack" => { "type" => "boolean" }
          "confidence" => { "type" => "float" }
          "attack_probability" => { "type" => "float" }
          "proto" => { "type" => "keyword" }
          "service" => { "type" => "keyword" }
          "state" => { "type" => "keyword" }
        }
      }
    }
  }

  # Alertes pour les attaques détectées avec confiance élevée
  if [is_attack] == true and [confidence] >= 0.7 {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "security-alerts-%{+YYYY.MM.dd}"
      document_type => "_doc"
    }
    
    # Log des alertes critiques
    file {
      path => "/usr/share/logstash/logs/intrusion-alerts.log"
      codec => json_lines
    }
  }

  # Debug/monitoring
  if [ml_error] {
    file {
      path => "/usr/share/logstash/logs/ml-errors.log"
      codec => json_lines
    }
  }

  # Output console pour debug (à supprimer en production)
  stdout { 
    codec => json_lines 
  }
}